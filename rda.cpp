#include "front.cpp"

/* Global declarations */
bool syntError = false;

/* Function declarations */
void program(void);
void stmt(void);
void declare_stmt(void);
void sel_stmt(void);
void loop_stmt(void);
void block(void);
void assign_stmt(void);
void expr(void);
void term(void);
void factor(void);
void syntaxError(void);

/*
-------------------------------------------------------
			Syntax analysis below
-------------------------------------------------------
/

/* rda.cpp - a syntax analyzer system for simple
 arithmetic expressions */
// #include "front.cpp"

/* program
 Parses strings in the language generated by the rule:
 <program> -> `[` <stmt> `]`
 */
void program(void)
{
	printf("Enter <program>\n");
	/* RHS is `[` <stmt> `]`, call lex to pass over the
	 left bracket, call <stmt>, and check for the right
	 bracket */
		if (nextToken == LEFT_BRACKET)
		{
			lex();
			stmt();
			if (nextToken == RIGHT_BRACKET)
				lex();
			else
				syntaxError();
		}
		/* It was not a left
		 bracket */
		else
			syntaxError();
	printf("Exit <program>\n");
}

// TODO: add if, while stmts
/* stmt
 Parses strings in the language generated by the rule:
 <stmt> --> <sel_stmt> | <loop_stmt> | <as_s> | <block>
 */
void stmt(void)
{
	printf("Enter <stmt>\n");
	/* Determine which RHS */
	switch (nextToken)
	{
		case TREVOR_SELECTION:
			sel_stmt();
			break;
		case TREVOR_LOOP:
			loop_stmt();
			break;
		case IDENT:
			assign_stmt();
			break;
		case LEFT_BRACE:
			block();
			break;
		case JUST_ONE_BYTE:
		case JUST_TWO_BYTES:
		case JUST_FOUR_BYTES:
		case JUST_EIGHT_BYTES:
			declare_stmt();
			break;
		
		default:
			printf("Add other cases to <stmt>\n");
			syntaxError();
			break;
	}
	printf("Exit <stmt>\n");
}

// TODO: Define sel_stmt and loop_stmt
void sel_stmt(void){}
void loop_stmt(void){}


/* declare_stmt
 Parses strings in the language generated by the rule:
<declare_stmt>  --> (`JUST_ONE_BYTE`|`JUST_TWO_BYTES`|`JUST_FOUR_BYTES`|`JUST_EIGHT_BYTES`) `ident`
 */
void declare_stmt(void){
	printf("Enter <declare_stmt>\n");
	if (nextToken == JUST_ONE_BYTE || nextToken == JUST_TWO_BYTES || nextToken == JUST_FOUR_BYTES || nextToken == JUST_EIGHT_BYTES){
		/* Get the next token */
		lex();
		if (nextToken == IDENT){
			lex();
		} else{
			syntaxError();
		}
	} else{
		syntaxError();
	}
	printf("Exit <declare_stmt>\n");
}

/* block
 Parses strings in the language generated by the rule:
<block> --> `{` { <stmt>`;` } `}`
 */
void block(void)
{
	printf("Enter <block>\n");
	/* Determine which RHS */
	if (nextToken == LEFT_BRACE){
		/* Get the next token */
		lex();
		while ((nextToken == TREVOR_SELECTION) || (nextToken == TREVOR_LOOP) || (nextToken == IDENT) || (nextToken == LEFT_BRACE) || (nextToken == JUST_ONE_BYTE || nextToken == JUST_TWO_BYTES || nextToken == JUST_FOUR_BYTES || nextToken == JUST_EIGHT_BYTES))
		{
			stmt();
			if (nextToken == SEMICOLON)
			{
				lex();
			} else{
				syntaxError();
			}
		}
		if (nextToken == RIGHT_BRACE){
			lex();
		} else{
			syntaxError();
		}
	} else{
		syntaxError();
	}
	printf("Exit <block>\n");
}

/* assign_stmt
 Parses strings in the language generated by the rule:
 <assign_stmt>  --> `ident` `=` <expr> `;`
 */
void assign_stmt(void)
{
	printf("Enter <assign_stmt>\n");
	/* Determine which RHS */
	if (nextToken == IDENT){
		/* Get the next token */
		lex();
		if (nextToken == ASSIGN_OP){
			lex();
			expr();
		} else{
			syntaxError();
		}
	} else{
		syntaxError();
	}
	printf("Exit <assign_stmt>\n");
}

/* expr
 Parses strings in the language generated by the rule:
 <expr> -> <term> { (`+`|`-`) <term> }
 */
void expr(void)
{
	printf("Enter <expr>\n");
	/* Parse the first term */
	term();
	/* As long as the next token is + or -, get
	 the next token and parse the next term */
	while (nextToken == ADD_OP || nextToken == SUB_OP)
	{
		lex();
		term();
	}
	printf("Exit <expr>\n");
}

/* term
 Parses strings in the language generated by the rule:
 <term> -> <factor> { (`*`|`/`|`%`) <factor> }
 */
void term(void)
{
	printf("Enter <term>\n");
	/* Parse the first factor */
	factor();
	/* As long as the next token is * or /, get the
	 next token and parse the next factor */
	while (nextToken == MULT_OP || nextToken == DIV_OP)
	{
		lex();
		factor();
	}
	printf("Exit <term>\n");
}

/* factor
 Parses strings in the language generated by the rule:
 <factor> -> id | int_constant | `(` <expr> `)`
 */
void factor(void)
{
	printf("Enter <factor>\n");
	/* Determine which RHS */
	if (nextToken == IDENT || nextToken == INT_LIT)
		/* Get the next token */
		lex();
	/* If the RHS is ( <expr> ), call lex to pass over the
	 left parenthesis, call expr, and check for the right
	 parenthesis */
	else
	{
		if (nextToken == LEFT_PAREN)
		{
			lex();
			expr();
			if (nextToken == RIGHT_PAREN)
				lex();
			else
				syntaxError();
		}
		/* It was not an id, an integer literal, or a left
		 parenthesis */
		else
			syntaxError();
	}
	printf("Exit <factor>\n");
}

/* syntaxError
 prints syntaxError message
 */
void syntaxError(void)
{
	// printf("\nSyntax Error!\n\n");
	syntError = true;
	printf("SYNTAX ERROR AT LEXEME %s \nSTOPPING EXECUTION NOW\n", lexeme);
	exit(1);
}

/****

Trace of the parse of (sum + 47) / total:
Next token is: 25, Next lexeme is (
Enter <expr>
Enter <term>
Enter <factor>
Next token is: 11, Next lexeme is sum
Enter <expr>
Enter <term>
Enter <factor>
Next token is: 21, Next lexeme is +
Exit <factor>
Exit <term>
Next token is: 10, Next lexeme is 47
Enter <term>
Enter <factor>
Next token is: 26, Next lexeme is )
Exit <factor>
Exit <term>
Exit <expr>
Next token is: 24, Next lexeme is /
Exit <factor>
Next token is: 11, Next lexeme is total
Enter <factor>
Next token is: -1, Next lexeme is EOF
Exit <factor>
Exit <term>
Exit <expr>

****/



